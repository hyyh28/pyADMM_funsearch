import numpy as np
import matplotlib.pyplot as plt
np.random.seed(1234)

# parameters for the scanning setup
nx, ny = 25, 25 # dimension of image
ns, nu = 50, 50 # number of source locations, number of detector cells
scanner_rad = 30 # radius from center to gantry (cm)
image_side = 10 # length of one side of square image array (cm)
theta = 4*np.arcsin(image_side/(np.sqrt(2.0)*scanner_rad)) # angle of the beam (radians)
phantom_rad = 5 # radius of the circular phantom (cm)
nk, nl = nx*ny, ns*nu # number of pixels, number of rays
energies = np.arange(1,100,2); ni = len(energies); energy_binwidth=2 # discretizing photon energy (keV)
nw = 3 # number of energy windows in detector
nm = 3 # number of materials
total_intensity = 10**6 # intensity of the X-ray beam (expected # of photons per detector cell for air scan)

# parameters for optimization
sig_grid = np.array([1,10,100]) # ADMM parameter
nsig = len(sig_grid)
niter = 10 # number of ADMM iterations
lamTV = 5 # total variation penalty when simulation is run with regularization
div_by_zero_thresh = 1e-8 # avoid dividing by zero with step size matrices
niter_newton = 10 # Newton-Raphson algorithm for solving convex subproblem

# generate phantom - a disk of pmma of radius phantom_rad,\
# with four smaller disks (two aluminum, two gadolinium/PMMA)
# centered at the points (+/- phantom_rad*0.4, +/- phantom_rad*0.4) with radius phantom_rad*0.25

x_true = np.zeros((nx,ny,nm))
materials_in_ball = np.array([[0,1,0],[0.99,0,0.01],[0,1,0],[0.99,0,0.01]])
ball_centers = np.array([[phantom_rad*0.4,phantom_rad*0.4],[phantom_rad*0.4,-phantom_rad*0.4],\
                         [-phantom_rad*0.4,-phantom_rad*0.4],[-phantom_rad*0.4,phantom_rad*0.4]])
ball_radii = np.array([phantom_rad*0.25,phantom_rad*0.25,phantom_rad*0.25,phantom_rad*0.25])
for ix in range(nx):
    for iy in range(ny):
        x_coord = (-image_side/2) + (image_side*ix)/float(nx)
        y_coord = (-image_side/2) + (image_side*iy)/float(ny)
        if x_coord**2+y_coord**2 <= phantom_rad**2:
            x_true[ix,iy,0] = 1
            for iball in range(len(ball_radii)):
                if (x_coord-ball_centers[iball,0])**2 + (y_coord-ball_centers[iball,1])**2 <\
                        ball_radii[iball]**2:
                    x_true[ix,iy] = materials_in_ball[iball]

def plot_x(x_list,title=None):
    vmin = np.ones(3)*np.inf
    vmax = np.ones(3)*-np.inf
    for x in x_list:
        vmin = np.minimum(vmin,x.min((0,1)))
        vmax = np.maximum(vmax,x.max((0,1)))
    for i in range(len(x_list)):
        plt.figure()
        plt.subplot(131)
        plt.imshow(x_list[i][:,:,0],vmin=vmin[0],vmax=vmax[0])
        plt.xlabel('PMMA')
        plt.xticks([])
        plt.yticks([])
        plt.colorbar(shrink=0.25)
        plt.subplot(132)
        plt.imshow(x_list[i][:,:,1],vmin=vmin[1],vmax=vmax[1])
        plt.xlabel('Aluminum')
        plt.xticks([])
        plt.yticks([])
        plt.colorbar(shrink=0.25)
        plt.subplot(133)
        plt.imshow(x_list[i][:,:,2],vmin=vmin[2],vmax=vmax[2])
        plt.xlabel('Gadolinium')
        plt.xticks([])
        plt.yticks([])
        plt.colorbar(shrink=0.25)
        plt.tight_layout()
        if(not(title is None)):
            plt.suptitle(title[i])
            plt.subplots_adjust(top=1.4)
        plt.show()

# plot_x([x_true],title=['Ground truth'])

# create source/detector response S

# create window functions with linear blur
blur_prop = 0.1 # width of blur on each side as a function of width of total range
blur_width = blur_prop*(energies.max() - energies.min())/nw
w_breaks = np.r_[1.,50.,70.,99.]
w_breaks[0] -= blur_width
w_breaks[-1] += blur_width
w_shape = np.zeros((nw,ni))

spectrum = np.c_[np.arange(10,102,2), np.array([0.00368,0.00355,0.00459,0.0077,0.01474,\
  0.02249,0.02691,0.03264,0.03889,0.04088,0.04307,0.04396,0.04428,0.04315,0.04284,0.04095,\
  0.03944,0.03795,0.03627,0.0346,0.03267,0.03113,0.02894,0.02733,0.02647,0.05175,0.02204,\
  0.02084,0.01866,0.02607,0.01502,0.01218,0.01121,0.01026,0.0092,0.00854,0.00749,0.00682,\
  0.00579,0.00486,0.00417,0.00324,0.0024,0.00168,0.00114,0.00017])]
# These values are taken from the following paper:
# "Diagnostic x-ray spectra: A comparison of spectra generated by
#     different computational methods with a measured spectrum"
# Bhat et al, Med. Phys. 25(1), 1998
# (Table I)

spectrum = np.exp(np.interp(energies, spectrum[:,0], np.log(spectrum[:,1]), \
                            left = -np.inf, right = -np.inf))
spectrum /= spectrum.sum()

for w_ in range(nw):
    w_shape[w_] = \
      (1 - np.minimum(np.maximum((w_breaks[w_] + blur_width - energies)/2/blur_width,0),1)\
       - np.minimum(np.maximum((energies - w_breaks[w_+1] + blur_width)/2/blur_width,0),1))\
        * spectrum


S = total_intensity * np.outer(w_shape,np.ones(nl)).reshape((nw,ni,nl)).transpose((0,2,1))
# constant across rays l_=1,..,nl i.e. no differences between different detector cells

# plt.figure(figsize=(10, 3))
# plt.subplot(121)
# plt.plot(energies,spectrum/energy_binwidth,label='X-ray beam') # rescaling to obtain a density
# plt.legend(loc='upper right')
# plt.xlabel('energy (units: keV)')
# plt.ylabel('photon spectral density')
# plt.subplot(122)
# plt.plot(energies,S[0,0]/total_intensity/energy_binwidth,label='window 1')
# plt.plot(energies,S[1,0]/total_intensity/energy_binwidth,label='window 2')
# plt.plot(energies,S[2,0]/total_intensity/energy_binwidth,label='window 3')
# plt.legend(loc='upper right')
# plt.xlabel('energy (units: keV)')
# plt.yticks([])
# plt.tight_layout()
# plt.show()

# attenuation coefficients scraped from NIST
# and interpolated on the log scale to the predefined energy levels

# sources for density:
# PMMA: https://physics.nist.gov/PhysRefData/XrayMassCoef/tab2.html
# aluminum & gadolinium: https://physics.nist.gov/PhysRefData/XrayMassCoef/tab1.html

# sources for mu_per_density (a.k.a mass attenuation coefficient):
# PMMA: https://physics.nist.gov/PhysRefData/XrayMassCoef/ComTab/pmma.html
# aluminum: https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/z13.html
# gadolinium: https://physics.nist.gov/PhysRefData/XrayMassCoef/ElemTab/z64.html
# mu is the linear attenuation coefficient (1/cm)

density_PMMA = 1.190
mu_per_density_PMMA = np.array([\
        2.79400000e+03, 1.23600000e+02, 2.68100000e+01, 1.00166012e+01,\
        4.66908535e+00, 2.68607749e+00, 1.71970094e+00, 1.10100000e+00,\
        8.46931890e-01, 6.51492848e-01, 5.36313998e-01, 4.72472923e-01,\
        4.16231282e-01, 3.66684463e-01, 3.23035537e-01, 2.95571846e-01,\
        2.80886455e-01, 2.66930703e-01, 2.53668338e-01, 2.41064909e-01,\
        2.32082263e-01, 2.26355019e-01, 2.20769110e-01, 2.15321048e-01,\
        2.10007431e-01, 2.05848821e-01, 2.02781180e-01, 1.99759255e-01,\
        1.96782364e-01, 1.93849835e-01, 1.91495742e-01, 1.89699956e-01,\
        1.87921010e-01, 1.86158746e-01, 1.84413009e-01, 1.82683642e-01,\
        1.80970493e-01, 1.79273409e-01, 1.77592240e-01, 1.75926836e-01,\
        1.74532885e-01, 1.73404160e-01, 1.72282734e-01, 1.71168560e-01,\
        1.70061593e-01, 1.68961784e-01, 1.67869087e-01, 1.66783457e-01,\
        1.65704848e-01, 1.64633215e-01])
mu_PMMA = mu_per_density_PMMA * density_PMMA

density_aluminum = 2.699
mu_per_density_aluminum = np.array([\
        1.18500000e+03, 7.88000000e+02, 1.93400000e+02, 7.61777461e+01,\
        3.63339497e+01, 2.06617294e+01, 1.28204546e+01, 7.95500000e+00,\
        5.68928879e+00, 4.06888837e+00, 3.07784762e+00, 2.46247597e+00,\
        1.97013908e+00, 1.57623792e+00, 1.26109167e+00, 1.05329794e+00,\
        9.18407688e-01, 8.00792108e-01, 6.98238929e-01, 6.08819189e-01,\
        5.44319639e-01, 4.99000607e-01, 4.57454752e-01, 4.19367927e-01,\
        3.84452140e-01, 3.57884146e-01, 3.38295129e-01, 3.19778329e-01,\
        3.02275059e-01, 2.85729841e-01, 2.73395705e-01, 2.64795487e-01,\
        2.56465807e-01, 2.48398154e-01, 2.40584285e-01, 2.33016217e-01,\
        2.25686218e-01, 2.18586800e-01, 2.11710708e-01, 2.05050917e-01,\
        2.00100689e-01, 1.96744874e-01, 1.93445339e-01, 1.90201138e-01,\
        1.87011345e-01, 1.83875047e-01, 1.80791347e-01, 1.77759362e-01,\
        1.74778226e-01, 1.71847085e-01])
mu_aluminum = mu_per_density_aluminum * density_aluminum

density_gadolinium = 7.900
mu_per_density_gadolinium = np.array([\
        2291.        , 1292.        ,  365.3       ,  156.89085391,\
        353.5249706 ,  217.87728117,  142.61431975,   93.35      ,\
         68.86248306,   50.79851713,   39.16968525,   31.57038073,\
         25.44541609,   20.50875489,   16.52985455,   13.74995004,\
         11.80417281,   10.13374561,    8.6997032 ,    7.46859441,\
          6.52744112,    5.8078675 ,    5.16761841,    4.59794925,\
          4.09107942,   17.98139263,   16.35911816,   14.88320467,\
         13.54044755,   12.31883346,   11.31984357,   10.50619708,\
          9.75103377,    9.05015002,    8.39964431,    7.79589558,\
          7.23554304,    6.71546746,    6.23277381,    5.78477517,\
          5.41272081,    5.10585873,    4.81639351,    4.54333887,\
          4.28576446,    4.04279264,    3.81359557,    3.59739231,\
          3.39344622,    3.20106238])
mu_gadolinium = mu_per_density_gadolinium * density_gadolinium

mu = np.c_[mu_PMMA,mu_aluminum,mu_gadolinium].T


# plt.plot(energies,mu_PMMA,label='PMMA')
# plt.plot(energies,mu_aluminum,label='aluminum')
# plt.plot(energies,mu_gadolinium,label='gadolinium')
# plt.legend(loc='upper right')
# plt.xlabel('energy (units: keV)')
# plt.ylabel('mass attenuation coef. '+r'$\mu/\rho$'+' (units: cm'+r'${}^2$'+'/g)')
# plt.yscale('log')
# plt.show()

# create projection matrix
P = np.zeros((ns,nu,nx,ny))
pixel_xs = -image_side/2+image_side*np.arange(1+nx)/nx
pixel_ys = -image_side/2+image_side*np.arange(1+ny)/ny

for s_ in range(ns):
    for u_ in range(nu):
        # compute length of intersection between pixel x,y and ray s,u
        source_angle = s_*2*np.pi/float(ns)
        source = np.r_[scanner_rad*np.cos(source_angle), scanner_rad*np.sin(source_angle)]
        # coordinates of source location

        detector_angle = source_angle + np.pi - (0.5-0.5/nu)*theta + u_*theta/float(nu)
        detector = np.r_[scanner_rad*np.cos(detector_angle), scanner_rad*np.sin(detector_angle)]
        # coordinates of detector cell location

        t_vals = np.zeros(0)
        if(source[0]!=detector[0]):
            t_vals = np.r_[t_vals, (pixel_xs - source[0])/(detector[0] - source[0])]
        if(source[1]!=detector[1]):
            t_vals = np.r_[t_vals, (pixel_ys - source[1])/(detector[1] - source[1])]
        t_vals = np.sort(np.unique(t_vals))
        t_vals = np.r_[0,t_vals[(0<t_vals) & (t_vals<1)],1]

        length = np.sqrt(((source-detector)**2).sum())

        for it in range(len(t_vals)-1):
            t = (t_vals[it] + t_vals[it+1])/2
            x_coord = (1-t) * source[0] + t * detector[0]
            y_coord = (1-t) * source[1] + t * detector[1]
            if((pixel_xs[0]<=x_coord)&(x_coord<=pixel_xs[nx])&(pixel_ys[0]<=y_coord)&(y_coord<=pixel_ys[ny])):
                ix = np.argwhere(pixel_xs<=x_coord).max()
                iy = np.argwhere(pixel_ys<=y_coord).max()
                P[s_,u_,ix,iy] = P[s_,u_,ix,iy] + length * (t_vals[it+1]-t_vals[it])



P = P.reshape((nl,nx,ny))

def Pmult(x): # apply projection operator to an image x
    Px = np.zeros((nl,nm))
    for m_ in range(nm):
        Px[:,m_] = (P*x[:,:,m_]).sum((1,2))
    return Px

def Ptmult(y): # transpose of the projection operator
    return np.dot(P.transpose((1,2,0)),y)

P_rowsums = Pmult(np.ones((nx,ny,nm)))[:,0]
P_rowsums[P_rowsums<div_by_zero_thresh] = div_by_zero_thresh # avoiding dividing by zero
P_colsums = Ptmult(np.ones((nl,nm)))[:,:,0]
P_colsums[P_colsums<div_by_zero_thresh] = div_by_zero_thresh # avoiding dividing by zero

def qexp(t,deriv=0):
    return np.exp(t*(t<=0))*(t<=0) + \
            (1+t+0.5*t**2)*((t>0)&(deriv==0)) + (1+t)*((t>0)&(deriv==1)) + ((t>0)&(deriv==2))

def get_c_hat_by_energy(y,deriv=0):
    # c_hat[w,l,i] = E[# photons in (w,l) at energy i]
    return (S * qexp(-np.dot(y,mu),deriv))

def get_c_hat(y,deriv=0):
    # c_hat[w,l] = E[# photons in (w,l), across all energies]
    return get_c_hat_by_energy(y,deriv).sum(2)

c = np.random.poisson(get_c_hat(Pmult(x_true))) # generate data

def get_loss(x,c):
    # poisson negative log likelihood, up to a constant term
    #   ( this constant term makes it nonnegative, & ensures that if c = c_hat then loss = 0 )
    c_hat = get_c_hat(Pmult(x))
    if min(c_hat[c>0])<=0:
        return np.inf
    else:
        return (c_hat.sum() - c.sum()) - (c[c>0]*np.log(c_hat[c>0]/c[c>0])).sum()

def get_gradient_expterm(y):
    # returns l-by-m gradient of the first term in the negative log likelihood
    c_hat_by_energy_1 = get_c_hat_by_energy(y,deriv=1)
    return -(mu[:,None,None,:] * c_hat_by_energy_1).sum((1,3)).T

def get_gradient_logexpterm(y,c):
    # returns l-by-m gradient of the second term in the negative log likelihood
    c_hat_by_energy_1 = get_c_hat_by_energy(y,deriv=1)
    c_hat = get_c_hat(y)
    c_hat[c_hat==0] = 1 # avoiding 0/0
    return (mu[:,None,None,:] * (c/c_hat)[:,:,None]*c_hat_by_energy_1).sum((1,3)).T

def get_hessian_expterm(y):
    # returns l-by-m-by-m 2nd derivative of the first term in the negative log likelihood
    c_hat_by_energy_2 = get_c_hat_by_energy(y,deriv=2)
    return (c_hat_by_energy_2.sum(0)[:,None,:]*mu).dot(mu.T)

# ADMM update steps
def x_update(x,y,u,c,sig):
    return x + (1/sig)*(Ptmult(sig*(y-Pmult(x))/P_rowsums[:,None]-u))/P_colsums[:,:,None]

def y_update(x,y,u,c,sig):
    grad_y = lambda y_: get_gradient_expterm(y_) + get_gradient_logexpterm(y,c) \
                        + sig*(y_-Pmult(x))/P_rowsums[:,None] - u
    hess_y = lambda y_: get_hessian_expterm(y_) + sig/P_rowsums[:,None,None] * np.eye(nm)
    y_ = np.copy(y)
    for iter in range(niter_newton):
        y_ = y_ - np.linalg.solve(hess_y(y_),grad_y(y_))
    return y_

def u_update(x,y,u,c,sig):
    return u + sig*(Pmult(x)-y)/P_rowsums[:,None]

# run simulation
x_store_iters = np.zeros((niter,nsig,nx,ny,nm))
y_store_iters = np.zeros((niter,nsig,nl,nm))
for isig in range(nsig):
    print(isig)
    sig = sig_grid[isig]
    x = np.zeros((nx,ny,nm))
    y = np.zeros((nl,nm))
    u = np.zeros((nl,nm))
    for iter in range(niter):
        print(iter)
        x = x_update(x,y,u,c,sig)
        y = y_update(x,y,u,c,sig)
        u = u_update(x,y,u,c,sig)
        x_store_iters[iter,isig] = np.copy(x)
        y_store_iters[iter,isig] = np.copy(y)

# plot results: true & estimated images

x_list = [x_true]
title_list = ['Ground truth']
for isig in range(nsig):
    x_list.append(x_store_iters[-1,isig])
    title_list.append('Estimated image (# iterations='+str(niter)+\
            ', ADMM parameter '+r'$\sigma=$'+str(sig_grid[isig])+')')

plot_x(x_list,title_list)