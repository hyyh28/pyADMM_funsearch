{"sample_order": 0, "function": "def lrsr(A, B, lambd1, lambd2, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    rho = opts.get('rho', 1.1)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l21')\n\n    d, na = A.shape\n    _, nb = B.shape\n\n    X = np.zeros((nb, na))\n    E = np.zeros((d, na))\n    Z = np.zeros_like(X)\n    J = np.zeros_like(X)\n\n    Y1 = np.zeros_like(E)\n    Y2 = np.zeros_like(X)\n    Y3 = np.zeros_like(X)\n\n    BtB = B.T @ B\n    BtA = B.T @ A\n    I = np.eye(nb)\n    invBtBI = np.linalg.inv(BtB + 2 * I)\n\n    for iter in range(max_iter):\n        Xk = X.copy()\n        Zk = Z.copy()\n        Ek = E.copy()\n        Jk = J.copy()\n\n        # First super block {Z, J, E}\n        Z, nuclearnormZ = prox_nuclear(X + Y2 / mu, 1 / mu)\n        J = prox_l1(X + Y3 / mu, lambd1 / mu)\n\n        if loss == 'l1':\n            E = prox_l1(A - B @ X + Y1 / mu, lambd2 / mu)\n        elif loss == 'l21':\n            E = prox_l21(A - B @ X + Y1 / mu, lambd2 / mu)\n        elif loss == 'l2':\n            E = mu * (A - B @ X + Y1 / mu) / (lambd2 + mu)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        # Second super block {X}\n        X = invBtBI @ (B.T @ (Y1 / mu - E) + BtA - (Y2 + Y3) / mu + Z + J)\n\n        dY1 = A - B @ X - E\n        dY2 = X - Z\n        dY3 = X - J\n\n        chgX = np.max(np.abs(Xk - X))\n        chgE = np.max(np.abs(Ek - E))\n        chgZ = np.max(np.abs(Zk - Z))\n        chgJ = np.max(np.abs(Jk - J))\n        chg = np.max([chgX, chgE, chgZ, chgJ, np.max(np.abs(dY1)), np.max(np.abs(dY2)), np.max(np.abs(dY3))])\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = nuclearnormZ + lambd1 * np.sum(np.abs(J)) + lambd2 * comp_loss(E, loss)\n                err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2 + np.linalg.norm(dY3, 'fro')**2)\n                print(f'iter {iter + 1}, mu={mu}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y1 += mu * dY1\n        Y2 += mu * dY2\n        Y3 += mu * dY3\n        mu = min(rho * mu, max_mu)\n\n    obj = nuclearnormZ + lambd1 * np.sum(np.abs(J)) + lambd2 * comp_loss(E, loss)\n    err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2 + np.linalg.norm(dY3, 'fro')**2)\n\n    return X, E, obj, err, iter\n\n", "score": -95.0}