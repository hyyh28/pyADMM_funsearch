{"sample_order": 9, "function": "def igc(A, C, lambd, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    tau_incr = opts.get('tau_incr', 2)\n    tau_decr = opts.get('tau_decr', 2)\n    eps_pri = opts.get('eps_pri', 1e-4)\n    eps_dual = opts.get('eps_dual', 1e-4)\n\n    C = np.abs(C)\n    d, n = A.shape\n\n    L = np.zeros((d, n))\n    S = np.zeros_like(L)\n    Z = np.zeros_like(L)\n    Y1 = np.zeros_like(L)\n    Y2 = np.zeros_like(L)\n\n    for iter in range(max_iter):\n        Lk = L.copy()\n        Sk = S.copy()\n        Zk = Z.copy()\n\n        # First super block {L, S}\n        L, nuclearnormL = prox_nuclear(Z - Y2 / mu, 1 / mu)\n        S = prox_l1(-Z + A - Y1 / mu, C * (lambd / mu))\n\n        # Second super block {Z}\n        Z = project_box((-S + A + L + (Y2 - Y1) / mu) / 2, 0, 1)\n\n        dY1 = Z + S - A\n        dY2 = L - Z\n        chgL = np.max(np.abs(Lk - L))\n        chgS = np.max(np.abs(Sk - S))\n        chgZ = np.max(np.abs(Zk - Z))\n        chg = np.max([chgL, chgS, chgZ, np.max(np.abs(dY1)), np.max(np.abs(dY2))])\n\n        # Compute primal and dual residuals\n        res_pri = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2)\n        res_dual = mu * np.sqrt(np.linalg.norm(Z - Zk, 'fro')**2 + np.linalg.norm(L - Lk, 'fro')**2)\n\n        # Update rho based on residuals\n        if res_pri > eps_pri * res_dual:\n            mu *= tau_incr\n        elif res_dual > eps_dual * res_pri:\n            mu /= tau_decr\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = nuclearnormL + lambd * np.sum(C * np.abs(S))\n                err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2)\n                print(f'iter {iter + 1}, mu={mu}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y1 += mu * dY1\n        Y2 += mu * dY2\n        mu = min(mu, max_mu)\n\n    obj = nuclearnormL + lambd * np.sum(C * np.abs(S))\n    err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2)\n\n    return L, S, obj, err, iter\n\n", "score": -999.0}