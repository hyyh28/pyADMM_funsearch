{"sample_order": 4, "function": "def lrr(A, B, lambd, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l21')\n\n    d, na = A.shape\n    _, nb = B.shape\n\n    X = np.zeros((nb, na))\n    E = np.zeros((d, na))\n    J = np.zeros_like(X)\n\n    Y1 = np.zeros_like(E)\n    Y2 = np.zeros_like(X)\n    BtB = B.T @ B\n    BtA = B.T @ A\n    I = np.eye(nb)\n    invBtBI = np.linalg.inv(BtB + I)\n\n    rho = 1.1  # Initial rho\n\n    for iter in range(max_iter):\n        Xk = X.copy()\n        Ek = E.copy()\n        Jk = J.copy()\n\n        # First super block {J, E}\n        J, nuclearnormJ = prox_nuclear(X + Y2 / mu, 1 / mu)\n        \n        if loss == 'l1':\n            E = prox_l1(A - B @ X + Y1 / mu, lambd / mu)\n        elif loss == 'l21':\n            E = prox_l21(A - B @ X + Y1 / mu, lambd / mu)\n        elif loss == 'l2':\n            E = (mu * (A - B @ X + Y1 / mu)) / (lambd + mu)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        # Second super block {X}\n        X = invBtBI @ (B.T @ (Y1 / mu - E) + BtA - Y2 / mu + J)\n\n        dY1 = A - B @ X - E\n        dY2 = X - J\n        chgX = np.max(np.abs(Xk - X))\n        chgE = np.max(np.abs(Ek - E))\n        chgJ = np.max(np.abs(Jk - J))\n        chg = np.max([chgX, chgE, chgJ, np.max(np.abs(dY1)), np.max(np.abs(dY2))])\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = nuclearnormJ + lambd * comp_loss(E, loss)\n                err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2)\n                print(f'iter {iter + 1}, mu={mu}, rho={rho}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        # Update rho dynamically\n        rho_update = 1.01 + 0.1 * np.exp(-iter / 100)\n        rho = min(max(rho * rho_update, 1.1), 10.0)\n\n        Y1 += mu * dY1\n        Y2 += mu * dY2\n        mu = min(rho * mu, max_mu)\n\n    obj = nuclearnormJ + lambd * comp_loss(E, loss)\n    err = np.sqrt(np.linalg.norm(dY1, 'fro')**2 + np.linalg.norm(dY2, 'fro')**2)\n\n    return X, E, obj, err, iter\n\n", "score": -17.0}