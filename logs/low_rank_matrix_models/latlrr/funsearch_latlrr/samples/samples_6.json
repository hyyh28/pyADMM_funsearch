{"sample_order": 6, "function": "def latlrr(X, lambd, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    rho = opts.get('rho', 1.1)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l1')\n\n    eta1 = 1.02 * 2 * np.linalg.norm(X, 2)**2  # for Z\n    eta2 = eta1  # for L\n    eta3 = 1.02 * 2  # for E\n\n    d, n = X.shape\n    E = np.zeros((d, n))\n    Z = np.zeros((n, n))\n    L = np.zeros((d, d))\n    Y = np.zeros_like(E)\n\n    XtX = X.T @ X\n    XXt = X @ X.T\n\n    def update_rho(rho, dY, mu):\n        norm_dY = np.linalg.norm(dY, 'fro')\n        if norm_dY > 10 * tol:\n            return rho * 1.5\n        elif norm_dY < tol / 10:\n            return rho / 1.5\n        return rho\n\n    for iter in range(max_iter):\n        Lk = L.copy()\n        Ek = E.copy()\n        Zk = Z.copy()\n\n        # First super block {Z}\n        Z, nuclearnormZ = prox_nuclear(Zk - (X.T @ (Y / mu + L @ X - X - E) + XtX @ Z) / eta1, 1 / (mu * eta1))\n\n        # Second super block {L, E}\n        temp = Lk - ((Y / mu + X @ Z - E) @ X.T + Lk @ XXt - XXt) / eta2\n        L, nuclearnormL = prox_nuclear(temp, 1 / (mu * eta2))\n\n        if loss == 'l1':\n            E = prox_l1(Ek + (Y / mu + X @ Z + Lk @ X - X - Ek) / eta3, lambd / (mu * eta3))\n        elif loss == 'l21':\n            E = prox_l21(Ek + (Y / mu + X @ Z + Lk @ X - X - Ek) / eta3, lambd / (mu * eta3))\n        elif loss == 'l2':\n            E = (Y + mu * (X @ Z + Lk @ X - X + (eta3 - 1) * Ek)) / (lambd + mu * eta3)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        dY = X @ Z + L @ X - X - E\n        chgL = np.max(np.abs(Lk - L))\n        chgE = np.max(np.abs(Ek - E))\n        chgZ = np.max(np.abs(Zk - Z))\n        chg = np.max([chgL, chgE, chgZ, np.max(np.abs(dY))])\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = nuclearnormZ + nuclearnormL + lambd * comp_loss(E, loss)\n                err = np.linalg.norm(dY, 'fro')**2\n                print(f'iter {iter + 1}, mu={mu}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y += mu * dY\n        mu = min(rho * mu, max_mu)\n        rho = update_rho(rho, dY, mu)\n\n    obj = nuclearnormZ + nuclearnormL + lambd * comp_loss(E, loss)\n    err = np.linalg.norm(dY, 'fro')**2\n\n    return Z, L, obj, err, iter\n\n", "score": -23.0}