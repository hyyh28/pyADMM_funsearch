{"sample_order": 0, "function": "def mlap(X, lambda_, alpha, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    rho = opts.get('rho', 1.1)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l21')\n\n    d, n, K = X.shape\n    Z = np.zeros((n, n, K))\n    E = np.zeros((d, n, K))\n    J = np.zeros_like(Z)\n    S = np.zeros_like(Z)\n    Y = np.zeros_like(E)\n    W = np.zeros_like(Z)\n    V = np.zeros_like(Z)\n    XtX = np.zeros((n, n, K))\n    invXtXI = np.zeros((n, n, K))\n    I = np.eye(n)\n\n    for i in range(K):\n        XtX[:, :, i] = X[:, :, i].T @ X[:, :, i]\n        invXtXI[:, :, i] = np.linalg.inv(XtX[:, :, i] + I)\n\n    nuclearnormJ = np.zeros(K)\n\n    for iter in range(max_iter):\n        Zk = Z.copy()\n        Ek = E.copy()\n        Jk = J.copy()\n        Sk = S.copy()\n\n        # First super block {J, S}\n        for i in range(K):\n            J[:, :, i], nuclearnormJ[i] = prox_nuclear(Z[:, :, i] + W[:, :, i] / mu, 1 / mu)\n            S[:, :, i] = invXtXI[:, :, i] @ (XtX[:, :, i] - X[:, :, i].T @ (E[:, :, i] - Y[:, :, i] / mu) + Z[:, :, i] + (V[:, :, i] - W[:, :, i]) / mu)\n\n        # Second super block {Z, E}\n        Z = prox_tensor_l21((J + S - (W + V) / mu) / 2, alpha / (2 * mu))\n\n        XmXS = np.zeros_like(E)\n        for i in range(K):\n            XmXS[:, :, i] = X[:, :, i] - X[:, :, i] @ S[:, :, i]\n\n        if loss == 'l1':\n            for i in range(K):\n                E[:, :, i] = prox_l1(XmXS[:, :, i] + Y[:, :, i] / mu, lambda_ / mu)\n        elif loss == 'l21':\n            for i in range(K):\n                E[:, :, i] = prox_l21(XmXS[:, :, i] + Y[:, :, i] / mu, lambda_ / mu)\n        elif loss == 'l2':\n            for i in range(K):\n                E[:, :, i] = (XmXS[:, :, i] + Y[:, :, i] / mu) / (lambda_ / mu + 1)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        dY = XmXS - E\n        dW = Z - J\n        dV = Z - S\n\n        chgZ = np.max(np.abs(Zk - Z))\n        chgE = np.max(np.abs(Ek - E))\n        chgJ = np.max(np.abs(Jk - J))\n        chgS = np.max(np.abs(Sk - S))\n        chg = np.max([chgZ, chgE, chgJ, chgS, np.max(np.abs(dY)), np.max(np.abs(dW)), np.max(np.abs(dV))])\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = np.sum(nuclearnormJ) + lambda_ * comp_loss(E, loss) + alpha * comp_loss(Z, 'l21')\n                err = np.sqrt(np.linalg.norm(dY)**2 + np.linalg.norm(dW)**2 + np.linalg.norm(dV)**2)\n                print(f'iter {iter + 1}, mu={mu}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y += mu * dY\n        W += mu * dW\n        V += mu * dV\n        mu = min(rho * mu, max_mu)\n\n    obj = np.sum(nuclearnormJ) + lambda_ * comp_loss(E, loss) + alpha * comp_loss(Z, 'l21')\n    err = np.sqrt(np.linalg.norm(dY)**2 + np.linalg.norm(dW)**2 + np.linalg.norm(dV)**2)\n\n    return Z, E, obj, err, iter\n\n", "score": null}