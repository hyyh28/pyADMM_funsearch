{"sample_order": 2, "function": "def rpca(X, lambda_, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l1')\n\n    d, n = X.shape\n    L = np.zeros((d, n))\n    S = np.zeros((d, n))\n    Y = np.zeros((d, n))\n    rho = opts.get('rho', 1.1)\n    tau_incr = opts.get('tau_incr', 2)\n    tau_decr = opts.get('tau_decr', 2)\n\n    for iter in range(max_iter):\n        Lk = L.copy()\n        Sk = S.copy()\n\n        # Update L\n        L, nuclearnormL = prox_nuclear(-S + X - Y / mu, 1 / mu)\n\n        # Update S\n        if loss == 'l1':\n            S = prox_l1(-L + X - Y / mu, lambda_ / mu)\n        elif loss == 'l21':\n            S = prox_l21(-L + X - Y / mu, lambda_ / mu)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        dY = L + S - X\n        chgL = np.max(np.abs(Lk - L))\n        chgS = np.max(np.abs(Sk - S))\n        chg = np.max([chgL, chgS, np.max(np.abs(dY))])\n\n        if DEBUG:\n            if iter == 0 or iter % 10 == 0:\n                obj = nuclearnormL + lambda_ * comp_loss(S, loss)\n                err = np.linalg.norm(dY, 'fro')\n                print(f'iter {iter + 1}, mu={mu}, rho={rho}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y += mu * dY\n        mu = min(rho * mu, max_mu)\n\n        # Update rho dynamically\n        if np.linalg.norm(dY, 'fro') > 10 * np.linalg.norm(L - Lk, 'fro'):\n            rho *= tau_incr\n        elif np.linalg.norm(L - Lk, 'fro') > 10 * np.linalg.norm(dY, 'fro'):\n            rho /= tau_decr\n\n    obj = nuclearnormL + lambda_ * comp_loss(S, loss)\n    err = np.linalg.norm(dY, 'fro')\n\n    return L, S, obj, err, iter\n\n", "score": -79.0}