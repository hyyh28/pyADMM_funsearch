{
  "sample_order": 2,
  "function": "def trace_lasso_admm(A, b, opts):\n    tol = opts.get('tol', 1e-6)\n    max_iter = opts.get('max_iter', 1000)\n    rho = opts.get('rho', 1.1)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    tau_incr = opts.get('tau_incr', 2)\n    tau_decr = opts.get('tau_decr', 2)\n\n    d, n = A.shape\n    x = np.zeros(n)\n    Z = np.zeros((d, n))\n    Y1 = np.zeros(d)\n    Y2 = np.zeros((d, n))\n    Atb = A.T @ b\n    AtA = A.T @ A\n    invAtA = np.linalg.inv(AtA + np.diag(np.diag(AtA)))\n\n    for iter in range(1, max_iter + 1):\n        xk = x.copy()\n        Zk = Z.copy()\n\n        # Update x\n        x = invAtA @ (-A.T @ Y1 / mu + Atb + diagAtB(A, -Y2 / mu + Z))\n        \n        # Update Z\n        Z, nuclearnorm = prox_nuclear(A @ np.diag(x) + Y2 / mu, 1 / mu)\n\n        # Compute residuals\n        dY1 = A @ x - b\n        dY2 = A @ np.diag(x) - Z\n        chgx = np.max(np.abs(xk - x))\n        chgZ = np.max(np.abs(Zk - Z))\n        chg = np.max([chgx, chgZ, np.max(np.abs(dY1)), np.max(np.abs(dY2))])\n\n        # Update rho dynamically\n        if np.linalg.norm(dY1) > 10 * np.linalg.norm(dY2):\n            rho *= tau_incr\n        elif np.linalg.norm(dY2) > 10 * np.linalg.norm(dY1):\n            rho /= tau_decr\n\n        if DEBUG and (iter == 1 or iter % 10 == 0):\n            obj = nuclearnorm\n            err = np.sqrt(np.linalg.norm(dY1) ** 2 + np.linalg.norm(dY2) ** 2)\n            print(f\"iter {iter}, mu={mu}, rho={rho}, obj={obj}, err={err}\")\n\n        if chg < tol:\n            break\n\n        Y1 += mu * dY1\n        Y2 += mu * dY2\n        mu = min(rho * mu, max_mu)\n\n    obj = nuclearnorm\n    err = np.sqrt(np.linalg.norm(dY1) ** 2 + np.linalg.norm(dY2) ** 2)\n    \n    return x, obj, err, iter\n\n",
  "score": null
}
