{
  "sample_order": 0,
  "function": "def tracelassoR(A, b, lambda_, opts):\n    tol = opts.get('tol', 1e-8)\n    max_iter = opts.get('max_iter', 500)\n    rho = opts.get('rho', 1.1)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    loss = opts.get('loss', 'l1')\n\n    d, n = A.shape\n    x = np.zeros(n)\n    Z = np.zeros((d, n))\n    e = np.zeros(d)\n    Y1 = np.zeros(d)\n    Y2 = np.zeros((d, n))\n\n    Atb = A.T @ b\n    AtA = A.T @ A\n    invAtA = inv(AtA + np.diag(np.diag(AtA)))\n\n    for iter in range(max_iter):\n        xk = x.copy()\n        ek = e.copy()\n        Zk = Z.copy()\n\n        # First super block {Z,e}\n        Z, nuclearnorm = prox_nuclear(A @ np.diag(x) - Y2 / mu, lambda_ / mu)\n        if loss == 'l1':\n            e = prox_l1(b - A @ x - Y1 / mu, 1 / mu)\n        elif loss == 'l2':\n            e = mu * (b - A @ x - Y1 / mu) / (1 + mu)\n        else:\n            raise ValueError('Unsupported loss function')\n\n        # Second super block {x}\n        x = invAtA @ (-A.T @ (Y1 / mu + e) + Atb + diagAtB(A, Y2 / mu + Z))\n\n        dY1 = A @ x + e - b\n        dY2 = Z - A @ np.diag(x)\n        chgx = np.max(np.abs(xk - x))\n        chge = np.max(np.abs(ek - e))\n        chgZ = np.max(np.abs(Zk - Z))\n        chg = max([chgx, chge, chgZ, np.max(np.abs(dY1)), np.max(np.abs(dY2))])\n\n        if DEBUG and (iter == 1 or iter % 10 == 0):\n            obj = comp_loss(e, loss) + lambda_ * nuclearnorm\n            err = np.sqrt(np.linalg.norm(dY1)**2 + np.linalg.norm(dY2)**2)\n            print(f'iter {iter}, mu={mu}, obj={obj}, err={err}')\n\n        if chg < tol:\n            break\n\n        Y1 = Y1 + mu * dY1\n        Y2 = Y2 + mu * dY2\n        mu = min(rho * mu, max_mu)\n\n    obj = comp_loss(e, loss) + lambda_ * nuclearnorm\n    err = np.sqrt(np.linalg.norm(dY1)**2 + np.linalg.norm(dY2)**2)\n    return x, e, obj, err, iter\n\n",
  "score": -65.0
}
