{
  "sample_order": 2,
  "function": "def ksupport_admm(A, B, k, opts):\n    tol = opts.get('tol', 1e-6)\n    max_iter = opts.get('max_iter', 1000)\n    mu = opts.get('mu', 1e-4)\n    max_mu = opts.get('max_mu', 1e10)\n    DEBUG = opts.get('DEBUG', 0)\n    rho_update_factor = opts.get('rho_update_factor', 1.1)\n    rho_tol = opts.get('rho_tol', 1e-3)\n\n    d, na = A.shape\n    _, nb = B.shape\n\n    X = np.zeros((na, nb))\n    Z = np.zeros_like(X)\n    Y1 = np.zeros((d, nb))\n    Y2 = np.zeros_like(X)\n\n    AtB = A.T @ B\n    I = np.eye(na)\n    invAtAI = np.linalg.inv(A.T @ A + I)\n\n    rho = mu\n\n    for iter in range(1, max_iter + 1):\n        Xk = X.copy()\n        Zk = Z.copy()\n\n        # Update X\n        temp = Z - Y2 / rho\n        temp = prox_ksupport(temp.flatten(), k, 1 / rho)\n        X = temp.reshape(na, nb)\n        \n        # Update Z\n        Z = invAtAI @ (-A.T @ Y1 / rho + AtB + Y2 / rho + X)\n\n        # Compute residuals\n        dY1 = A @ Z - B\n        dY2 = X - Z\n        chgX = np.max(np.abs(Xk - X))\n        chgZ = np.max(np.abs(Zk - Z))\n        chg = np.max([chgX, chgZ, np.max(np.abs(dY1)), np.max(np.abs(dY2))])\n\n        if DEBUG and (iter == 1 or iter % 10 == 0):\n            err = np.sqrt(np.linalg.norm(dY1) ** 2 + np.linalg.norm(dY2) ** 2)\n            print(f\"iter {iter}, mu={mu}, rho={rho}, err={err}\")\n\n        if chg < tol:\n            break\n\n        # Update rho dynamically\n        if np.linalg.norm(dY1) > rho_tol * np.linalg.norm(dY2):\n            rho *= rho_update_factor\n        elif np.linalg.norm(dY2) > rho_tol * np.linalg.norm(dY1):\n            rho /= rho_update_factor\n\n        Y1 += rho * dY1\n        Y2 += rho * dY2\n        mu = min(rho_update_factor * mu, max_mu)\n\n    err = np.sqrt(np.linalg.norm(dY1) ** 2 + np.linalg.norm(dY2) ** 2)\n    return X, err, iter\n\n",
  "score": -290.0
}
